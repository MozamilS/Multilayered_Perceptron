# -*- coding: utf-8 -*-
"""multilayerd_perceptron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SuAxpAas7GzfUU2vZ5WBSuyq_QWuZjOi
"""

#!pip install yfinance
#!pip install yahoofinancials
import numpy as np
import pandas as pd
import yfinance as yf
from yahoofinancials import YahooFinancials
training_data = [
    {
        'inputs': np.array([0, 0]),
        'targets': np.array([0])
    }, {
        'inputs': np.array([1, 1]),
        'targets': np.array([0])
    }, {
        'inputs': np.array([0, 1]),
        'targets': np.array([1])
    }, {
        'inputs': np.array([1, 0]),
        'targets': np.array([1])
    }
]

tsla_df = yf.download('TSLA',
                      start='2019-01-01',
                      end='2019-12-31',
                      progress=False)


tsla_df = yf.download('TSLA',start='2021-06-08',
                      end = '2021-07-09', interval = "15m")

aapl_df = yf.download('AAPL',start='2021-06-08',
                      end = '2021-07-09', interval = "15m")

gold_df = yf.download('GC=F',start='2021-06-08',
                      end = '2021-07-09', interval = "15m")


training_data2 = []
for each in range(len(tsla_df)-40):
  training_data2.append(
      {
          "inputs": [],
          "targets": []
      }
  )
  for one in range(each, each+40):

    #print(one)
    #training_data2[-1]["inputs"].append(tsla_df["Open"][one])
    #training_data2[-1]["inputs"].append(tsla_df["High"][one])
    #training_data2[-1]["inputs"].append(tsla_df["Low"][one])

    if (tsla_df["Open"][one] >= tsla_df["Close"][one] ):
      training_data2[-1]["inputs"].append(0)
    else:
      training_data2[-1]["inputs"].append(1)
  if (tsla_df["Close"][each+39] > tsla_df["Close"][each+40]):
      training_data2[-1]["targets"].append(0)
  else:
      training_data2[-1]["targets"].append(1)

training_data3 = []
for each in range(len(aapl_df)-40):
  training_data3.append(
      {
          "inputs": [],
          "targets": []
      }
  )
  for one in range(each, each+40):

    #print(one)
    #training_data2[-1]["inputs"].append(tsla_df["Open"][one])
    #training_data2[-1]["inputs"].append(tsla_df["High"][one])
    #training_data2[-1]["inputs"].append(tsla_df["Low"][one])

    if (aapl_df["Open"][one] >= aapl_df["Close"][one] ):
      training_data3[-1]["inputs"].append(0)
    else:
      training_data3[-1]["inputs"].append(1)
  if (aapl_df["Close"][each+39] > aapl_df["Close"][each+40]):
      training_data3[-1]["targets"].append(0)
  else:
      training_data3[-1]["targets"].append(1)

training_data4 = []
for each in range(len(gold_df)-40):
  training_data4.append(
      {
          "inputs": [],
          "targets": []
      }
  )
  for one in range(each, each+40):

    #print(one)
    #training_data2[-1]["inputs"].append(tsla_df["Open"][one])
    #training_data2[-1]["inputs"].append(tsla_df["High"][one])
    #training_data2[-1]["inputs"].append(tsla_df["Low"][one])

    if (gold_df["Open"][one] >= gold_df["Close"][one] ):
      training_data4[-1]["inputs"].append(0)
    else:
      training_data4[-1]["inputs"].append(1)
  if (gold_df["Close"][each+39] > gold_df["Close"][each+40]):
      training_data4[-1]["targets"].append(0)
  else:
      training_data4[-1]["targets"].append(1)



class mutilayered_perceptron:
    def sigmoid(self, x):
        return 1/(1 + np.exp(-x))

    def sigmoid_derivative(self, x):
        return (x * (1-x))

    def __init__(self,Input_num,Hidden_num, Output_num):
        self.Input_Num = Input_num
        self.Hidden_Num = Hidden_num
        self.Output_Num = Output_num
        self.learning_rate = 0.1

        #for each in range(i)
        #self.weights_ih = np.random.randn(self.Input_Num,self.Hidden_Num)
        self.weights_ih = np.zeros([self.Input_Num, self.Hidden_Num])
        self.biases_ih = np.random.randn(self.Hidden_Num)

        self.weights_ho = np.zeros([self.Hidden_Num, self.Output_Num])
        self.biases_ho = np.zeros(self.Output_Num)


        for each in range(len(self.weights_ih)):
            for one in range(len(self.weights_ih[each])):
                self.weights_ih[each][one] = (np.random.random() * 2) - 1

        self.weights_ih = self.weights_ih.reshape((self.Input_Num, self.Hidden_Num))

        for each in range(len(self.biases_ih)):
            self.biases_ih[each] = (np.random.random()*2) - 1

        for each in range(len(self.weights_ho)):
            for one in range(len(self.weights_ho[each])):
                self.weights_ho[each][one] = (np.random.random() * 2) - 1

        self.weights_ho = self.weights_ho.reshape((self.Hidden_Num, self.Output_Num))


        for each in range(len(self.biases_ho)):
            self.biases_ho[each] = (np.random.random()*2) - 1

    def detes(self):
        print(self.weights_ho)
        print(self.biases_ho)
        print(self.weights_ih)
        print(self.biases_ih)
        #print(np.dot(self.weights_ih, self.biases_ih))



    def feedforward(self, data):
        hidden = np.dot(data, self.weights_ih)
        hidden = hidden.reshape((1,self.Hidden_Num))

        hidden += self.biases_ih
        for each in range(len(hidden)):
            hidden[each] = self.sigmoid(hidden[each])

        self.ih = hidden
        self.ih = self.ih.reshape((1,self.Hidden_Num))

        hidden = np.dot(hidden, self.weights_ho)
        hidden += self.biases_ho
        for each in range(len(hidden)):
            hidden[each] = self.sigmoid(hidden[each])

        self.ho = hidden.reshape((1,self.Output_Num))

        return self.ho

    def train(self, inputs, targets):
        hidden = np.dot(inputs, self.weights_ih)
        hidden = hidden.reshape((1,self.Hidden_Num))
        hidden += self.biases_ih
        for each in range(len(hidden)):
            hidden[each] = self.sigmoid(hidden[each])

        self.ih = hidden
        self.ih = self.ih.reshape((1,self.Hidden_Num))

        hidden = np.dot(hidden, self.weights_ho)
        hidden += self.biases_ho
        for each in range(len(hidden)):
            hidden[each] = self.sigmoid(hidden[each])

        self.ho = hidden.reshape((1,self.Output_Num))
        self.error = targets - self.ho
        self.gradients_output = self.ho

        for each in range(len(self.gradients_output)):
            self.gradients_output[each] = self.sigmoid_derivative(self.gradients_output[each])
        self.gradients_output *= self.error*self.learning_rate


        self.hidden = self.ho.reshape((self.Output_Num, 1))
        self.gradients_output = self.gradients_output.reshape((1, self.Output_Num))
        self.biases_ho = self.biases_ho + self.gradients_output

        self.gradients_output = (np.array(np.dot(self.ih.T, self.gradients_output)))
        self.weights_ho= self.gradients_output + self.weights_ho
        for each in range(len(self.ih)):
            self.ih[each] = self.sigmoid_derivative(self.ih[each])

        #Transponsing the inputs


        self.biases_ih = self.biases_ih + np.dot(self.error, self.weights_ho.T)*self.ih *self.learning_rate


        self.weights_ih = np.dot(inputs, np.dot(self.error, self.weights_ho.T)*self.ih *self.learning_rate)+self.weights_ih



        #Printing the weights and biases of the output layer
        #print("self.biases_ih is: ")
        #print(self.weights_ho)
        #print("self.biases_ih is: ")
        #print(self.biases_ho)


nn = mutilayered_perceptron(40,10000,2)


for each in range(1):
  guess = np.random.randint(0,1982)
  training_data4[guess]['targets'] = [1,0]
  nn.train(np.array(training_data4[guess]['inputs']),np.array(training_data4[guess]['targets']))
  print(each/99999)


right = 0
total = 0
#for each in range(len(training_data4)):
  #total += 1
  #print("")
  #print("Training Data number: " + str(each))
  #print(training_data4[each]["targets"])
  #print(nn.feedforward(np.array(training_data4[each]["inputs"]))[0][0])
  #if((nn.feedforward(np.array(training_data4[each]["inputs"]))[0][0] < 0.3) and (training_data4[each]["targets"][0] == 0)):
    #right += 1
    #print("right++")
  #elif((nn.feedforward(np.array(training_data4[each]["inputs"]))[0][0] > 0.7) and (training_data4[each]["targets"][0] == 1)):
    #right += 1
    #print("right++")

#print(right/total)
#print("")




#nn.train(training_data[0]['inputs'], training_data[0]['targets'])

!pip install yfinance
!pip install yahoofinancials
import numpy as np
import pandas as pd
import yfinance as yf
import copy


from yahoofinancials import YahooFinancials

def add_data(ticker, dataset, input_length, interval1 = "15m"):
  dataframe = yf.download(ticker,start='2021-06-08',
                      end = '2021-07-09', interval = interval1)

  for each in range(len(dataframe)-input_length):
    dataset.append(
      {
          "inputs": [],
          "targets": []
      }
    )
    for one in range(each, each+input_length):

      #print(one)
      #training_data2[-1]["inputs"].append(tsla_df["Open"][one])
      #training_data2[-1]["inputs"].append(tsla_df["High"][one])
      #training_data2[-1]["inputs"].append(tsla_df["Low"][one])

      if (dataframe["Open"][one] >= dataframe["Close"][one] ):
        dataset[-1]["inputs"].append(0)
      else:
        dataset[-1]["inputs"].append(1)
    if (dataframe["Close"][each+input_length-1] > dataframe["Close"][each+input_length]):
        dataset[-1]["targets"].append(0)
    else:
        dataset[-1]["targets"].append(1)





class Neural_Network:
    def sigmoid(self, x):
        return 1 / (1 + np.exp(-x))

    def sigmoid_derivative(self, x):
        return (x * (1 - x))

    def __init__(self, Hidden_num, learning_rate = 0.1):
        self.Hidden_Num = Hidden_num
        self.learning_rate = 0.1
        self.layer_weights = []
        self.layer_biases = []
        for each in range(1, len(self.Hidden_Num)):
          self.layer_weights.append(
              np.zeros([self.Hidden_Num[each-1], self.Hidden_Num[each]])
          )
          for each2 in range(self.Hidden_Num[each-1]):
              for one in range(self.Hidden_Num[each]):
                self.layer_weights[-1][each2][one] = (np.random.random() * 2) - 1
          self.layer_weights[-1].reshape((self.Hidden_Num[each-1], self.Hidden_Num[each]))
          self.layer_biases.append(np.random.randn(self.Hidden_Num[each]))
          for each2 in range(self.Hidden_Num[each]):
            self.layer_biases[-1][each2] = (np.random.random()*2) - 1
          self.layer_biases[-1] = self.layer_biases[-1].reshape((1,self.Hidden_Num[each]))

    def detes(self):
        print(self.weights_ho)
        print(self.biases_ho)
        print(self.weights_ih)
        print(self.biases_ih)
        print(np.dot(self.weights_ih, self.biases_ih))

    def feedforward(self, data):
        self.layer_results = []
        self.layer_results.append(np.array(data).reshape((1,self.Hidden_Num[0])))
        self.layer_results[-1]=self.layer_results[-1].astype('float64')
        for each in range( len(self.layer_weights)):
          self.layer_results.append(np.dot(self.layer_results[-1], self.layer_weights[each]))
          self.layer_results[-1] = self.layer_results[-1].reshape((1,self.Hidden_Num[each+1]))
          self.layer_results[-1] += self.layer_biases[each]
          for one in range(len(self.layer_results[-1])):
            for ever in range(len(self.layer_results[-1][one])):
              self.layer_results[-1][one][ever] = self.sigmoid(self.layer_results[-1][one][ever])
        return self.layer_results[-1]

    def train(self, data, targets):
        self.layer_results = []
        self.layer_results.append(np.array(data).reshape((1,self.Hidden_Num[0])))
        self.layer_results[-1]=self.layer_results[-1].astype('float64')
        for each in range( len(self.layer_weights)):
          self.layer_results.append(np.dot(self.layer_results[-1], self.layer_weights[each]))
          self.layer_results[-1] = self.layer_results[-1].reshape((1,self.Hidden_Num[each+1]))
          self.layer_results[-1] += self.layer_biases[each]
          for one in range(len(self.layer_results[-1])):
            for ever in range(len(self.layer_results[-1][one])):
              self.layer_results[-1][one][ever] = self.sigmoid(self.layer_results[-1][one][ever])
        differences = targets - self.layer_results[-1]
        differences *= self.learning_rate
        self.layer_results_copy = copy.deepcopy(self.layer_results)
        for each in range(1, len(self.layer_results)):
          for one in range(len(self.layer_results[each])):
            for ever in range(len(self.layer_results[each][one])):
              self.layer_results[each][one][ever] = self.sigmoid_derivative(self.layer_results[each][one][ever])
        for each in range(len(self.layer_weights) - 1, -1, -1):
          error = differences
          layer_results_counter = 2
          for open in range(len(self.layer_weights)-1, each, -1):
            if open < len(self.layer_weights):
              layer_results_counter += 1
              error = np.dot(error, self.layer_weights[open].T)*self.layer_results[len(self.layer_results)-layer_results_counter+1]
          gradient_variable = error
          self.layer_biases[each] += gradient_variable
          self.layer_weights[each] += np.dot(self.layer_results_copy[len(self.layer_results_copy)-layer_results_counter].T, gradient_variable)
          self.layer_biases[each] = self.layer_biases[each]+gradient_variable


training_data = [
    {
        'inputs': np.array([0, 0]),
        'targets': np.array([0])
    }, {
        'inputs': np.array([1, 1]),
        'targets': np.array([1])
    }, {
        'inputs': np.array([0, 1]),
        'targets': np.array([1])
    }, {
        'inputs': np.array([1, 0]),
        'targets': np.array([1])
    }
]

def training_function(dataset, iterations, shape_temp):
  shape_temp[0] = len(dataset[0]['inputs'])
  shape_temp[-1] = len(dataset[0]['targets'])

  nn = Neural_Network(shape_temp)

  for each in range(iterations+1):
    guess = np.random.randint(0,len(dataset))
    nn.train(np.array(training_data2[guess]['inputs']),np.array(training_data2[guess]['targets']))
    print(each/iterations)
  right = 0
  total = 0
  right1 = 0
  total1 = 0
  for each in range(len(dataset)):
    total += 1
    print("")
    print("Training Data number: " + str(each))
    print(dataset[each]["targets"])
    print(nn.feedforward(np.array(dataset[each]["inputs"]))[0][0])
    if((nn.feedforward(np.array(dataset[each]["inputs"]))[0][0] < 0.3) and (dataset[each]["targets"][0] == 0)):
      right += 1
      print("right++")
    elif((nn.feedforward(np.array(dataset[each]["inputs"]))[0][0] > 0.7) and (dataset[each]["targets"][0] == 1)):
      right += 1
      print("right++")
  for each in range(len(training_data5)):
    total1 += 1
    print("")
    print("Training Data number: " + str(each))
    print(training_data5[each]["targets"])
    print(nn.feedforward(np.array(training_data5[each]["inputs"]))[0][0])
    if((nn.feedforward(np.array(training_data5[each]["inputs"]))[0][0] < 0.3) and (training_data5[each]["targets"][0] == 0)):
      right1 += 1
      print("right++")
    elif((nn.feedforward(np.array(training_data5[each]["inputs"]))[0][0] > 0.7) and (training_data5[each]["targets"][0] == 1)):
      right1 += 1
      print("right++")
  print("")
  print(right/total)

  print(right1/total1)

input_length1 = 150

training_data5 = []
add_data("GC=F", training_data5, input_length=input_length1)

training_data2 = []
add_data("GBPUSD=X", training_data2, input_length=input_length1)
add_data("JPY=X", training_data2, input_length=input_length1)
add_data("CHF=X", training_data2, input_length=input_length1)
add_data("CAD=X", training_data2, input_length=input_length1)
add_data("CHFJPY=X", training_data2, input_length=input_length1)
add_data("EURGBP=X", training_data2, input_length=input_length1)
add_data("EURCHF=X", training_data2,input_length=input_length1)
add_data("EURJPY=X", training_data2,input_length=input_length1)
add_data("EURCAD=X", training_data2,input_length=input_length1)
add_data("GBPCHF=X", training_data2,input_length=input_length1)
add_data("GBPJPY=X", training_data2,input_length=input_length1)
add_data("CADCHF=X", training_data2,input_length=input_length1)
add_data("GBPCAD=X", training_data2,input_length=input_length1)
add_data("CADJPY=X", training_data2,input_length=input_length1)






#training_function(training_data2, 5000000, [input_length1,input_length1,1])
print(len(training_data2))

right = 0
total = 0